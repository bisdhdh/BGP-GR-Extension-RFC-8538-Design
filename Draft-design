FRR BGP-GR Extension - RFC 8538 Scoping for FRR-Main( > 7.1 )
Skip to end of metadata
Created by Biswajit Sadhu, last modified on May 17, 2019
Go to start of metadata
1. Problem Statement:
BGP GR implementation in FRR is as per RFC 4724 and limits the usage of BGP Graceful Restart to BGP messages only. For many classes of errors, BGP must send a NOTIFICATION message and reset the peering session to handle the error condition.  The BGP Graceful Restart mechanism defined in RFC 4724 requires that normal BGP procedures defined in RFC 4271 be followed when a NOTIFICATION message is sent or received, there by loosing all the routes and flapping reachability.

2. Objective:
The primary objective is to enhance the Helper capability for BGP speaking routes. This is achieved by allowing the BGP speaker to avoid flapping reachability and continue forwarding while the BGP speaker restarts the session to handle errors detected in BGP.
RFC 8538 updates  RFC 4724 by defining an extension that permits the Graceful Restart procedures to be performed when the BGP speaker receives a BGP NOTIFICATION message or the Hold Time expires. RFC 8538 defines a new subcode for BGP Cease NOTIFICATION messages. This  new subcode is needed to requests a full session restart instead of a Graceful Restart.
When a BGP session is reset, both speakers operate as "Receiving Speakers", and they retain each other’s routes.
When a BGP session HOLDTIME expires, both speakers operate as "Receiving Speakers", and they retain each other’s routes.
The functionality can be defeated by sending a BGP Cease NOTIFICATION message with the Hard Reset subcode.  If a Hard Reset is used, a full session reset is performed for that neighbor.
3. Solution:
3.1. High Level Design:
The new BGP GR capability, the "N" bit much be sent in the BGP open message from the sending router and the receiving router must be capability of processing the new capability.  So this involves changes in both sender and receiving router.
Both the sender and the receiver must fall back to the procedure mention in RFC 4724, when the above capability RFC 8538 is administrative disable. This involves introducing a CLI knob to control this feature, both at the sender and receiver router.
When any established BGP session under goes reset, the router must follow bgp graceful restart procedure of "Receiving Speaker", this includes both the sending and receiving router. So when a router sends or receives a notification message,  all notification except "hard reset", qualifies for "Graceful Cease" i.e. follow the procedure of  "Receiving Speaker". However whenever, any "Hard Reset" notification send or received, the router must follow normal procedure of reseting the session as mention in RFC 4271. This involves changes in both at the sender and the receiver side.
Similar functionality changes will have to be done for HOLDTIME expiry i.e. when HOLDTIME expires, both speakers operate as "Receiving Speakers", and they retain each other’s routes.
BGP GR Peer Down Detection Flow would under go some change in-order to implement the above points.
Peer down, is primary detected by BGP IO module form TCP Session close. If GR is enabled then it lets the close reason to PEER_DOWN_NSF_CLOSE_SESSION and set PEER_STATUS_NSF_WAIT bit in  peer sflags, there by marking the start of BGP GR. In this flow it generates TCP_connection_closed or TCP_fatal_error BGP event. 

If  event raised is TCP_connection_closed, the action function that is called is bgp_stop() or bgp_ignore(), depending on the present state.

if event raised is TCP_fatal_error, the action function that is called is bgp_stop or bgp_connect_fail or bgp_fsm_exeption or bgp_ignore, depending on the present state. bgp_fsm_exeption() internally calls bgp_stop().  bgp_connect_fail () also calls bgp_stop() it also calls peer_delete() if it is dynamic neighbour.

So the bottom line is, bgp_stop() would be evenbgp_clear_stale_routetually get called with PEER_STATUS_NSF_WAIT set in this flow. All the house keeping is done in this flow. However if BGP GR is enabled, it does some special processing like start the restart and the stale path timer.

Stale marking flow :

The routes learned by this peer is marked STALE (BGP_PATH_STALE) in bgp_clear_route_node()

 
bgp_read( ) → bgp_event( ) → bgp_event_update( TCP_fatal_error/TCP_connection_closed ) → Next-state of this peer is "Clearing" → bgp_fsm_change_status(Clearing)

bgp_fsm_change_status(struct peer *peer, int status) - if the status is clearing or Deleted , it would call bgp_clear_route_all( )

bgp_clear_route_all() → bgp_clear_route() → bgp_clear_route_table() → work_queue_add(peer->clear_node_queue, cnq)

bgp_clear_route_node() sets the stale mark on the route on bgp_path_info→flags for that bgp_node only if PEER_STATUS_NSF_WAIT is set and the route is not already marked as stale.



So the bottom line is, bgp_stop() would be evenbgp_clear_stale_routetually get called with PEER_STATUS_NSF_WAIT set in this flow. All the house keeping is done in this flow. However if BGP GR is enabled, it does some special processing like start the restart and the stale path timer.

Define new Hard Reset Notification. This involves writing new encoder and decoder functionality of the new Hard Reset Notification.
As suggested in RFC 8538, hard reset notification should be sent from all the places listed below in the "Low Level Design" section.
3.2. Low Level Design:
                  Note: All pseudocode in this section, marked in green are the new proposed code changes. 

3.2.1. BGP GR Extension - RFC 8538 Capability Exchange :
Restart Flags:

This field contains bit flags relating to restart.

                0 1 2 3

               +-+-+-+-+

               |R|N|   |

               +-+-+-+-+

The most significant bit is defined in [RFC4724] as the Restart State ("R") bit. The second most significant bit is defined as the Graceful Notification ("N") bit. It is used to indicate Graceful Restart support for BGP NOTIFICATION messages.  A BGP speaker indicates support for RFC 8538 by advertising Graceful Restart Capability with its "N" bit set (value 1).

If a BGP speaker that previously advertised a given set of Graceful Restart parameters opens a new session with a different set of parameters, these new parameters apply once the session has transitioned into ESTABLISHED state.



Data-structure changes:

BGPD.H

/* BGP instance structure.  */

struct bgp {

        /* AS number of this BGP instance.  */

        as_t as;

..

        /* BGP flags. */

        u_int32_t flags;

#define BGP_FLAG_GRACEFUL_RESTART_DISABLE (1 << 23)

#define BGP_FLAG_SELECT_DEFER_DISABLE     (1 << 24)

+   #define BGP_FLAG_GRACEFUL_NOTIFICATION    (1 << 25)

..

}



/* BGP neighbor structure. */

struct peer {

..

.. 

/* Capability flags (reset in bgp_stop) */

u_int32_t cap;

#define PEER_CAP_REFRESH_ADV                (1 << 0) /* refresh advertised */

..

#define PEER_CAP_RESTART_ADV                (1 << 5) /* restart advertised */

#define PEER_CAP_RESTART_RCV                (1 << 6) /* restart received *

..

#define PEER_CAP_HOSTNAME_RCV               (1 << 16) /* hostname received */

+   #define PEER_CAP_GRACEFUL_NOTIFICATION_ADV  (1 << 17) /* Graceful Notification ("N") bit advertise */

+   #define PEER_CAP_GRACEFUL_NOTIFICATION_RCV  (1 << 17) /* Graceful Notification ("N") bit received */

.. 

}

BGP_OPEN.H

/* Graceful Restart */

#define RESTART_R_BIT              0x8000 

#define RESTART_N_BIT              0x4000

#define RESTART_F_BIT              0x80

  

3.2.2. CLI Knobs :
A new CLI would be introduced to enable and disable this feature. The default setting would be "enable". Once the setting is changed vis this CLI, we must rest all teh BGP session cmd : clear bgp 
Router(config)# bgp graceful-restart-disable-N-bit

A new CLI would be introduced for user to Hard clear BGP session. This command would lead to clearing of the BGP session and send a Hard reset notification to the neighbour. This command should only be used BGP Graceful Notification is enabled.
  This command will have two variants :

1. Clear all the BGP session  

Router# clear bgp * Hard

2. Clear the BGP session to some specific neighbour

Router# clear bgp <IPV4 address | IPV6 address> Hard



3.2.3. Sending Capability : 
        Pseudocode for sending new GR capability :

bgp_open_capability() → bgp_peer_send_gr_capability()



Pseudocode :

void bgp_peer_send_gr_capability(struct stream *s, struct peer *peer,

                         unsigned long cp,unsigned long capp,

                         unsigned long rcapp)

{

..

if (bgp_peer_flag_check(peer, PEER_FLAG_GRACEFUL_RESTART) ||

bgp_flag_check(peer->bgp, BGP_FLAG_GRACEFUL_RESTART))

restart_bit = true;

 

if ((bgp_peer_flag_check(peer, PEER_FLAG_GRACEFUL_RESTART))||

(bgp_peer_flag_check(peer, PEER_FLAG_GRACEFUL_RESTART_HELPER) ) )

 

..

restart_time = peer->bgp->restart_time;

if ((peer->bgp->t_startup) && (restart_bit)) {

SET_FLAG(restart_time, RESTART_R_BIT);

SET_FLAG(peer->cap, PEER_CAP_RESTART_BIT_ADV);

}

       if (CHECK_BIT(peer->bgp->flags, BGP_FLAG_GRACEFUL_NOTIFICATION)) {

       SET_FLAG(peer->cap, PEER_CAP_GRACEFUL_NOTIFICATION_ADV);

       SET_FLAG(restart_time, RESTART_N_BIT);

       }

stream_putw(s, restart_time); 

..

}

3.2.4. Receiving Capability : 
 Pseudocode for receiving new GR capability :

bgp_capability_parse() → bgp_capability_restart()



Pseudocode :

static int bgp_capability_restart(struct peer *peer,

                          struct capability_header *caphdr)

{

struct stream *s = BGP_INPUT(peer);

u_int16_t restart_flag_time;

size_t end = stream_get_getp(s) + caphdr->length;

 

..

..

SET_FLAG(peer->cap, PEER_CAP_RESTART_RCV);

restart_flag_time = stream_getw(s);

if (CHECK_FLAG(restart_flag_time, RESTART_R_BIT))

   SET_FLAG(peer->cap, PEER_CAP_RESTART_BIT_RCV);

+      if (CHECK_FLAG(restart_flag_time, RESTART_N_BIT))

+     SET_FLAG(peer->cap, PEER_CAP_GRACEFUL_NOTIFICATION_RCV);

..

..

}

3.2.5. Role of BGP Speakers sending/receiving BGP Notification
As per RFC 4724, it is noted that the normal BGP procedures MUST be followed when the TCP session terminates due to the sending or receiving of a BGP NOTIFICATION message. So we should not carry out any activity related to BGP Graceful Restart while sending notification.

As per RFC 8538, the role of the BGP router, sending and receiving Notification are as follows:

3.2.5.1. Sending Speaker:
The role of BGP Speaker sending a BGP NOTIFICATION ( other than a Hard Reset ) message to its  neighbor,  would follow the rules for the Receiving Speaker i.e. Helper.

Pseudocode :

void bgp_notify_send_with_data(struct peer *peer, uint8_t code,
                                          uint8_t sub_code, uint8_t *data, size_t datalen)
{

struct stream *s;

..

..

/* peer reset cause */
if (code == BGP_NOTIFY_CEASE) {
if (sub_code == BGP_NOTIFY_CEASE_ADMIN_RESET)
peer->last_reset = PEER_DOWN_USER_RESET;
else if (sub_code == BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN)
peer->last_reset = PEER_DOWN_USER_SHUTDOWN;
else
peer->last_reset = PEER_DOWN_NOTIFY_SEND;
} else
peer->last_reset = PEER_DOWN_NOTIFY_SEND;

/* Add packet to peer's output queue */
stream_fifo_push(peer->obuf, s);

if (peer->status == Established && (BGP GR Capability send and rcv flag check) &&

   (CHECK_FLAG(peer->cap, PEER_CAP_GRACEFUL_NOTIFICATION_RCV) &&

   (CHECK_FLAG(peer->cap, PEER_CAP_GRACEFUL_NOTIFICATION_ADV))) {

if (CHECK_FLAG(peer->sflags, PEER_STATUS_NSF_MODE))  {

SET_FLAG(peer->sflags, PEER_STATUS_NSF_WAIT);

}

}

bgp_write_notify(peer);

pthread_mutex_unlock(&peer→io_mtx);

}



3.2.5.2. Receiving Speaker:
The role of BGP Speaker receiving a BGP NOTIFICATION ( other than a Hard Reset ) message from the neighbor, would follow the rules for the Receiving Speaker i.e. Helper.

When BGP packets are received function bgp_process_packet() is called and if the message type is BGP_MSG_NOTIFY, function bgp_notify_receive() is called. This would lead to the generation of Event -"Receive_NOTIFICATION_message". The action to this even is either bgp_stop or  bgp_stop_with_error or bgp_fsm_exeption or  bgp_ignore bgp_ignore. 

bgp_fsm_exeption() internally calls bgp_stop().  bgp_stop_with_error()/bgp_connect_fail () also calls bgp_stop() it also calls peer_delete() if it is dynamic neighbour.

Call flow :

bgp_process_packet() → bgp_event_update( "Receive_NOTIFICATION_message") → Next-state of this peer is "Clearing" → bgp_fsm_change_status(Clearing)

However in this flow PEER_STATUS_NSF_WAIT flag is not set. So as mentioned in the above "BGP GR Peer Down Detection Flow" ,  bgp_clear_route_node() would be called but does-not mark the routes stale as  PEER_STATUS_NSF_WAIT flag is not set.

Pseudocode :

/*BGP packets received will be processed here */

int bgp_process_packet(struct thread *thread)
{

..

..

if (peer->status == Deleted || peer->status == Clearing)
return 0;

unsigned int processed = 0;

..

switch (type) {

..

case BGP_MSG_NOTIFY:


atomic_fetch_add_explicit(&peer->notify_in, 1,
memory_order_relaxed);
mprc = bgp_notify_receive(peer, size);



if(((CHECK_FLAG(peer->cap, PEER_CAP_GRACEFUL_NOTIFICATION_RCV) &&
   (CHECK_FLAG(peer->cap, PEER_CAP_GRACEFUL_NOTIFICATION_ADV)) &&

   ((peer->status == Established) &&

   !((BGP_NOTIFY_CEASE == bgp_notify.code) && 
    (BGP_NOTIFY_CEASE_HARD_RESET == bgp_notify.subcode)))) {

if (CHECK_FLAG(peer->sflags, PEER_STATUS_NSF_MODE)) {

       SET_FLAG(peer->sflags, PEER_STATUS_NSF_WAIT);

       }

}

}

}

3.2.6.  Holdtime Timer Expiry
When Holdtimer expires for a neighbor, the BGP session is reset as per RFC 4271. As per RFC 8538, when a BGP speaker resets its session due to a HOLDTIME expiry, it should generate the relevant BGP NOTIFICATION message as mentioned in RFC 4271 but subsequently MUST follow the rules for the Receiving Speaker.

bgp_event() → bgp_event_update(Hold_Timer_expired) →

Event "Hold_Timer_expired" would result executing action bgp_ignore, bgp_fsm_exeption, bgp_fsm_holdtime_expire, bgp_stop, depending on the present state. When the present state is "Established", the next state would be "Clearing", the action would be bgp_fsm_holdtime_expire(). It would send a BGP notiofication with notification with code "BGP_NOTIFY_HOLD_ERR".

Pseudocode :

/* Hold timer expire. This is error of BGP connection. So cut the
peer and change to Idle status. */
static int bgp_fsm_holdtime_expire(struct peer *peer)
{
if (bgp_debug_neighbor_events(peer))
zlog_debug("%s [FSM] Hold timer expire", peer→host);



if (peer->status == Established &&

   (CHECK_FLAG(peer->cap, PEER_CAP_GRACEFUL_NOTIFICATION_RCV) &&

   (CHECK_FLAG(peer->cap, PEER_CAP_GRACEFUL_NOTIFICATION_ADV))) {

if (CHECK_FLAG(peer->sflags, PEER_STATUS_NSF_MODE))  {

SET_FLAG(peer->sflags, PEER_STATUS_NSF_WAIT);

}

}

return bgp_stop_with_notify(peer, BGP_NOTIFY_HOLD_ERR, 0);
}

3.2.7. BGP Hard Reset Subcode :
A new subcode for BGP Cease NOTIFICATION messages, called the Hard Reset subcode has been defined. 

IANA has assigned subcode 9 ("Hard Reset") in the "BGP Cease NOTIFICATION message subcodes" registry.

When the "N" bit has been exchanged by two peers, NOTIFICATION messages other than Hard Reset messages are referred to as "Graceful", since such messages invoke Graceful Restart semantics.



Data-structure changes:

BGPD.H

/* BGP notify message codes.  */

..

#define BGP_NOTIFY_FSM_ERR 5
#define BGP_NOTIFY_CEASE 6
#define BGP_NOTIFY_CAPABILITY_ERR 7

#define BGP_NOTIFY_CEASE_CONFIG_CHANGE 

 

/* BGP_NOTIFY_CEASE sub codes (RFC 4486).  */
..
#define BGP_NOTIFY_CEASE_OUT_OF_RESOURCE 8
#define BGP_NOTIFY_CEASE_HARD_RESET 9



/* peer reset cause */
char last_reset; or uint32 last_reset;

char last_hard_reset

Here we can either introduce a new char is_last_rest_hard or convert the above last_reset into bit mask of 32 bit and reuse it for hard_reset too. This decision would be taken in coding phase depending how much chnages has to be made to the old code.



#define PEER_DOWN_RID_CHANGE 1 /* bgp router-id command */

..

..

#define PEER_DOWN_IF_DOWN 25 /* Interface down */
#define PEER_DOWN_NBR_ADDR_DEL 26 /* Peer address lost */

#define PEER_DOWN_HARD_RTESET_SEND 27 /* HARD RESET  Notification Send  */

#define PEER_DOWN_HARD_RTESET_RCV 28  /* HARD RESET  Notification Recieved  */



/* BGP Notify message format. */
struct bgp_notify {
uint8_t code;
uint8_t subcode;

uint8_t inner_code;
uint8_t inner_subcode;

char *data;
bgp_size_t length;
uint8_t *raw_data;
};

3.2.8. Sending Hard Reset Notification 
When the "N" bit has been exchanged, a Hard Reset message is used to indicate to the peer that the session is to be fully terminated. When sending a Hard Reset, the data portion of the NOTIFICATION message is encoded as follows:

       +--------+--------+--------

       | ErrCode| Subcode| Data

       +--------+--------+--------

ErrCode is a BGP Error Code (as documented in the IANA "BGP Error (Notification) Codes" registry) that indicates the reason for the Hard Reset. Subcode is a BGP Error Subcode (as documented in the IANA "BGP Error Subcodes" registry) as appropriate for the ErrCode. Similarly, Data is as appropriate for the ErrCode and Subcode.

So, the Hard Reset encapsulates another NOTIFICATION message in its data portion.

Pseudocode :

static int bgp_notify_send_hard_reset (struct peer *peer, uint8_t code, uint8_t sub_code, uint8_t *data, size_t datalen) 

{ 

struct stream *s;

/* Lock I/O mutex to prevent other threads from pushing packets */
pthread_mutex_lock(&peer->io_mtx);



/* Allocate new stream. */
s = stream_new(BGP_MAX_PACKET_SIZE);



/* Make notify packet. */
bgp_packet_set_marker(s, BGP_MSG_NOTIFY);



/* Set Hard Reset notify packet values. */
stream_putc(s, BGP_NOTIFY_CEASE); /* BGP notify code */
stream_putc(s, BGP_NOTIFY_CEASE_HARD_RESET ); /* BGP notify sub_code */



/* Set original notify packet values. */
stream_putc(s, code); /* BGP notify code */
stream_putc(s, sub_code ); /* BGP notify sub_code */


/* If notify data is present. */
if (data)
stream_write(s, data, datalen);



/* Set BGP packet length. */
bgp_packet_set_size(s);



/* wipe output buffer */
stream_fifo_clean(peer→obuf);



/* For debug */
{

Code to dump the packes for debugging

}

/*
* If possible, store last packet for debugging purposes. This check is
* in place because we are sometimes called with a doppelganger peer,
* who tends to have a plethora of fields nulled out.
*/
if (peer->curr && peer->last_reset_cause_size) {
size_t packetsize = stream_get_endp(peer->curr);
assert(packetsize <= peer->last_reset_cause_size);
memcpy(peer->last_reset_cause, peer->curr->data, packetsize);
peer->last_reset_cause_size = packetsize;
}

/* peer reset cause */

if (code == BGP_NOTIFY_CEASE) {

    if (sub_code == BGP_NOTIFY_CEASE_ADMIN_RESET)

            peer->last_reset = PEER_DOWN_USER_RESET;

      else if (sub_code == BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN)

             peer->last_reset = PEER_DOWN_USER_SHUTDOWN;

      else

              peer->last_reset = PEER_DOWN_NOTIFY_SEND;

} else

peer->last_reset = PEER_DOWN_NOTIFY_SEND; 

peer->last_hard_reset = PEER_DOWN_HARD_RESET_SEND;



/* Add packet to peer's output queue */
stream_fifo_push(peer->obuf, s);

bgp_write_notify(peer);

pthread_mutex_unlock(&peer→io_mtx);

}

void bgp_notify_send(struct peer *peer, uint8_t code, uint8_t sub_code)
{

 bgp_notify_send_with_data(peer, code, sub_code, NULL, 0);

}

3.2.9. Receiving Hard Reset Notification 
Whenever a BGP speaker receives a Hard Reset, the speaker MUST terminate the BGP session following the standard procedures in [RFC4271].



Pseudocode :

bgp_process_packet(struct thread *thread) → static int bgp_notify_receive(struct peer *peer, bgp_size_t size)



static int bgp_notify_receive(struct peer *peer, bgp_size_t size)
{

struct bgp_notify bgp_notify;

if (peer->notify.data) {
XFREE(MTYPE_TMP, peer->notify.data);
peer->notify.data = NULL;
peer->notify.length = 0;
}

bgp_notify.code = stream_getc(peer->curr);
bgp_notify.subcode = stream_getc(peer->curr);
bgp_notify.length = size - 2;
bgp_notify.data = NULL;

/* Preserv notify code and sub code. */
peer->notify.code = bgp_notify.code;
peer->notify.subcode = bgp_notify.subcode;

if(((CHECK_FLAG(peer->cap, PEER_CAP_GRACEFUL_NOTIFICATION_RCV) &&
(CHECK_FLAG(peer->cap, PEER_CAP_GRACEFUL_NOTIFICATION_ADV)) &&
((BGP_NOTIFY_CEASE == bgp_notify.code) && 
(BGP_NOTIFY_CEASE_HARD_RESET == bgp_notify.subcode))

{

if(bgp_notify.length) {
bgp_notify.inner_code = stream_getc(peer->curr);
bgp_notify.inner_subcode = stream_getc(peer->curr);
bgp_notify.length = bgp_notify.length - 2;

/* Preserv notify code and sub code. */
peer->notify.inner_code = bgp_notify.inner_code;
peer->notify.inner_subcode = bgp_notify.inner_subcode;

peer->last_hard_reset = PEER_DOWN_HARD_RESET_RCV;
}
}

/* For further diagnostic record returned Data. */
if (bgp_notify.length) {
peer->notify.data = XMALLOC(MTYPE_TMP, bgp_notify.length);
memcpy(peer->notify.data, stream_pnt(peer->curr), bgp_notify.length);
}
..

..

/* peer count update */
atomic_fetch_add_explicit(&peer->notify_in, 1, memory_order_relaxed);

peer->last_reset = PEER_DOWN_NOTIFY_RECEIVED;

/* We have to check for Notify with Unsupported Optional Parameter.
in that case we fallback to open without the capability option.
But this done in bgp_stop. We just mark it here to avoid changing
the fsm tables. */
if (bgp_notify.code == BGP_NOTIFY_OPEN_ERR
&& bgp_notify.subcode == BGP_NOTIFY_OPEN_UNSUP_PARAM)
UNSET_FLAG(peer->sflags, PEER_STATUS_CAPABILITY_OPEN);

return Receive_NOTIFICATION_message;

}

3.2.10. Use of Hard Reset
3.2.10.1. When to Send a Hard Reset
When to send a Hard Reset is an implementation-specific decision, RFC 8538 offer some advice.  Many Cease NOTIFICATION subcodes represent permanent or long-term, rather than transient, session termination.  Because    of this, it’s appropriate to use Hard Reset with them.  As of publication of this document, subcodes 1-9 have been defined for Cease.  The following table lists each of these subcodes along with suggested behaviour. These suggestions are only that -- suggestions, not requirements. It’s the nature of BGP implementations that the mapping of internal states to BGP NOTIFICATION codes and subcodes is not always perfect.

   +-------+------------------------------------+----------------------+

   | Value |                Name                |  Suggested Behaviour  |

   +-------+------------------------------------+----------------------+

   |   1   | Maximum Number of Prefixes Reached |      Hard Reset      |

   |   2   |      Administrative Shutdown       |      Hard Reset      |

   |   3   |         Peer De-configured         |      Hard Reset      |

   |   4   |        Administrative Reset        | Provide user control |

   |   5   |        Connection Rejected         |    Graceful Cease    |

   |   6   |     Other Configuration Change     |    Graceful Cease    |

   |   7   |  Connection Collision Resolution   |    Graceful Cease    |

   |   8   |          Out of Resources          |    Graceful Cease    |

   |   9   |             Hard Reset             |      Hard Reset      |

   +-------+------------------------------------+----------------------+

3.2.10.2.  Proposed Behaviour in FRR for each of the Notification below : 
We can discuss all these points based on FRR requirement.

3.2.10.2.1. Maximum Number of Prefixes Reached. 
According to RFC 8538 it is suggested "Max Number of Prefix Reached": i.e. code 1, would follow Hard Reset Cease and I propose we should follow the same in FRR.

Pseudocode :

int bgp_maximum_prefix_overflow(struct peer *peer, afi_t afi, safi_t safi,
int always)
{

..

SET_FLAG(peer->sflags, PEER_STATUS_PREFIX_OVERFLOW);
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_MAX_PREFIX,
ndata, 7);

..


}

3.2.10.2.2. Administrative Shutdown
According to RFC 8538 it is suggested "Administrative Shutdown": i.e. code 2, would follow Hard Reset Cease and I propose we should follow the same in FRR.

Pseudocode :

void bgp_instance_down(struct bgp *bgp)
{
struct peer *peer;
struct listnode *node;
struct listnode *next;

..

..

/* Bring down peers, so corresponding routes are purged. */
for (ALL_LIST_ELEMENTS(bgp->peer, node, next, peer)) {
if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status))
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN);
else
bgp_session_reset(peer);
}

/* Purge network and redistributed routes. */
bgp_purge_static_redist_routes(bgp);

/* Cleanup registered nexthops (flags) */
bgp_cleanup_nexthops(bgp);
}

 

/* Delete BGP instance. */
int bgp_delete(struct bgp *bgp)
{
struct peer *peer;
struct peer_group *group;
struct listnode *node, *next;
struct vrf *vrf;
afi_t afi;
int i;

..

..

/* Inform peers we're going down. */
for (ALL_LIST_ELEMENTS(bgp->peer, node, next, peer)) {
if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status))
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN);
}

..

}

 

static void peer_flag_modify_action(struct peer *peer, uint32_t flag)
{
if (flag == PEER_FLAG_SHUTDOWN) {

..

..

bgp_notify_send_hard_reset(
peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN,
msgbuf, msglen + 1);
} else
bgp_notify_send_hard_reset(
peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN);
} else
bgp_session_reset(peer);
} else {

..

}

3.2.10.2.3. Peer De-configured
According to RFC 8538 it is suggested "Peer De-configure": i.e. code 3, would follow Hard Reset Cease and I propose we should follow the same in.

Pseudocode :

void bgp_terminate(void)
{

..

for (ALL_LIST_ELEMENTS(bm->bgp, mnode, mnnode, bgp))
for (ALL_LIST_ELEMENTS(bgp->peer, node, nnode, peer))
if (peer->status == Established
|| peer->status == OpenSent
|| peer->status == OpenConfirm)
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_PEER_UNCONFIG);

..

}

3.2.10.2.4. Administrative Reset
According to RFC 8538 it is suggested "Administrative Reset": i.e. code 4, can take either Graceful Cease or Hard Reset. I propose we should follow the Hard Reset path in FRR.

Pseudocode :

int peer_clear(struct peer *peer, struct listnode **nnode)
{

..


peer->v_start = BGP_INIT_START_TIMER;
if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status))
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_ADMIN_RESET);
else
bgp_session_reset_safe(peer, nnode);

..

}

3.2.10.2.5. Other Configuration Change 
According to RFC 8538 it is recommended "Other Configuration Change: i.e. code 6, would follow Graceful Cease and we many not use Hard Reset. However in FRR, we should implement this notification as Hard Reset as most of the config change related to BGP falls into this range and it would preserve the old behaviour of FRR during BGP config changes.

Pseudocode :

static int bgp_router_id_set(struct bgp *bgp, const struct in_addr *id)
{

..

..

if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status)) {
peer->last_reset = PEER_DOWN_RID_CHANGE;
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
}
}

int bgp_cluster_id_set(struct bgp *bgp, struct in_addr *cluster_id)
{
struct peer *peer;
struct listnode *node, *nnode;

..

..

if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status)) {
peer->last_reset = PEER_DOWN_CLID_CHANGE;
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
}

}

int bgp_cluster_id_unset(struct bgp *bgp)
{
struct peer *peer;
struct listnode *node, *nnode;

if (!bgp_config_check(bgp, BGP_CONFIG_CLUSTER_ID))
return 0;

..

..

if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status)) {
peer->last_reset = PEER_DOWN_CLID_CHANGE;
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
}
}

 

/* BGP confederation configuration. */
int bgp_confederation_id_set(struct bgp *bgp, as_t as)
{
struct peer *peer;
struct listnode *node, *nnode;
int already_confed;

..

bgp_notify_send_hard_reset(
peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);

..

}

int bgp_confederation_id_unset(struct bgp *bgp)
{

..

if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status)) {
peer->last_reset = PEER_DOWN_CONFED_ID_CHANGE;
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
}

..

}

 

/* Add an AS to the confederation set. */
int bgp_confederation_peers_add(struct bgp *bgp, as_t as)
{
struct peer *peer;
struct listnode *node, *nnode;

..

if (BGP_IS_VALID_STATE_FOR_NOTIF(
peer->status)) {
peer->last_reset =
PEER_DOWN_CONFED_PEER_CHANGE;
bgp_notify_send_hard_reset(
peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);

..

}

 

int bgp_confederation_peers_remove(struct bgp *bgp, as_t as)
{
int i;
int j;
struct peer *peer;
struct listnode *node, *nnode;

..

..

if (BGP_IS_VALID_STATE_FOR_NOTIF(
peer->status)) {
peer->last_reset =
PEER_DOWN_CONFED_PEER_CHANGE;
bgp_notify_send_hard_reset(
peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
} else
bgp_session_reset_safe(peer, &nnode);

..

}

 

/* Change peer's AS number. */
void peer_as_change(struct peer *peer, as_t as, int as_specified)
{
bgp_peer_sort_t type;

..

/* Stop peer. */
if (!CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)) {
if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status)) {
peer->last_reset = PEER_DOWN_REMOTE_AS_CHANGE;
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
} else
bgp_session_reset(peer);
}

..

}

 

static int peer_activate_af(struct peer *peer, afi_t afi, safi_t safi)
{
int active;
struct peer *other;

..

} else {
peer->last_reset = PEER_DOWN_AF_ACTIVATE;
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
}
}
if (peer->status == OpenSent || peer->status == OpenConfirm) {
peer->last_reset = PEER_DOWN_AF_ACTIVATE;
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
}

..

..

other = peer->doppelganger;
if (other
&& (other->status == OpenSent
|| other->status == OpenConfirm)) {
other->last_reset = PEER_DOWN_AF_ACTIVATE;
bgp_notify_send_hard_reset(other, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
}

}



static int non_peergroup_deactivate_af(struct peer *peer, afi_t afi,
safi_t safi)
{

..

..

} else {
peer->last_reset = PEER_DOWN_NEIGHBOR_DELETE;
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
}
} else {
peer->last_reset = PEER_DOWN_NEIGHBOR_DELETE;
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
}

..

}

  

/* Bind specified peer to peer group. */
int peer_group_bind(struct bgp *bgp, union sockunion *su, struct peer *peer,
struct peer_group *group, as_t *as)
{
int first_member = 0;
afi_t afi;
safi_t safi;

..

..

SET_FLAG(peer->flags, PEER_FLAG_CONFIG_NODE);

if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status)) {
peer->last_reset = PEER_DOWN_RMAP_BIND;
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
} else {
bgp_session_reset(peer);
}
}

..

..

/* Bring down peers, so corresponding routes are purged. */
for (ALL_LIST_ELEMENTS(bgp->peer, node, next, peer)) {
if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status))
bgp_notify_send(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN);
else
bgp_session_reset(peer);
}

/* Purge network and redistributed routes. */
bgp_purge_static_redist_routes(bgp);

/* Cleanup registered nexthops (flags) */
bgp_cleanup_nexthops(bgp);
}

 

void peer_change_action(struct peer *peer, afi_t afi, safi_t safi,
enum peer_change_type type)
{
if (CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP))
return;

..

..


if (type == peer_change_reset) {
/* If we're resetting session, we've to delete both peer struct
*/
if ((peer->doppelganger)
&& (peer->doppelganger->status != Deleted)
&& (!CHECK_FLAG(peer->doppelganger->flags,
PEER_FLAG_CONFIG_NODE)))
peer_delete(peer->doppelganger);

bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
} else if (type == peer_change_reset_in) {

..

bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
}

 

static void peer_flag_modify_action(struct peer *peer, uint32_t flag)
{
if (flag == PEER_FLAG_SHUTDOWN) {
if (CHECK_FLAG(peer->flags, flag)) {

..

..

} else if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status)) {
if (flag == PEER_FLAG_DYNAMIC_CAPABILITY)
peer->last_reset = PEER_DOWN_CAPABILITY_CHANGE;
else if (flag == PEER_FLAG_PASSIVE)
peer->last_reset = PEER_DOWN_PASSIVE_CHANGE;
else if (flag == PEER_FLAG_DISABLE_CONNECTED_CHECK)
peer->last_reset = PEER_DOWN_MULTIHOP_CHANGE;

bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
} else

..

}

 

/* EBGP multihop configuration. */
int peer_ebgp_multihop_set(struct peer *peer, int ttl)
{
struct peer_group *group;
struct listnode *node, *nnode;
struct peer *peer1;

..

 

if (!CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)) {
if (peer->fd >= 0 && peer->sort != BGP_PEER_IBGP) {
if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status))
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
else
bgp_session_reset(peer);
}
} else {
group = peer->group;
for (ALL_LIST_ELEMENTS(group->peer, node, nnode, peer)) {
if (peer->sort == BGP_PEER_IBGP)
continue;

peer->ttl = group->conf->ttl;

if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status))
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
else
bgp_session_reset(peer);
}

 

/* Neighbor update-source. */
int peer_update_source_if_set(struct peer *peer, const char *ifname)
{
struct peer *member;
struct listnode *node, *nnode;

..

if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status)) {
peer->last_reset = PEER_DOWN_UPDATE_SOURCE_CHANGE;
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
} else
bgp_session_reset(peer);

/* Skip peer-group mechanics for regular peers. */
return 0;
}

 

for (ALL_LIST_ELEMENTS(peer->group->peer, node, nnode, member)) {
/* Skip peers with overridden configuration. */
if (CHECK_FLAG(member->flags_override, PEER_FLAG_UPDATE_SOURCE))
continue;

..

..

/* Send notification or reset peer depending on state. */
if (BGP_IS_VALID_STATE_FOR_NOTIF(member->status)) {
member->last_reset = PEER_DOWN_UPDATE_SOURCE_CHANGE;
bgp_notify_send_hard_reset(member, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
} else
bgp_session_reset(member);
}

}

 

int peer_update_source_addr_set(struct peer *peer, const union sockunion *su)
{
struct peer *member;
struct listnode *node, *nnode;

 

..

..

/* Check if handling a regular peer. */
if (!CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)) {
/* Send notification or reset peer depending on state. */
if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status)) {
peer->last_reset = PEER_DOWN_UPDATE_SOURCE_CHANGE;
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
} else
bgp_session_reset(peer);

/* Skip peer-group mechanics for regular peers. */
return 0;
}

}

for (ALL_LIST_ELEMENTS(peer->group->peer, node, nnode, member)) {
/* Skip peers with overridden configuration. */
if (CHECK_FLAG(member->flags_override, PEER_FLAG_UPDATE_SOURCE))
continue;

..

..

/* Send notification or reset peer depending on state. */
if (BGP_IS_VALID_STATE_FOR_NOTIF(member->status)) {
member->last_reset = PEER_DOWN_UPDATE_SOURCE_CHANGE;
bgp_notify_send_hard_reset(member, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
} else
bgp_session_reset(member);
}

 

int peer_update_source_unset(struct peer *peer)
{
struct peer *member;
struct listnode *node, *nnode;

 

/* Check if handling a regular peer. */
if (!CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)) {
/* Send notification or reset peer depending on state. */
if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status)) {
peer->last_reset = PEER_DOWN_UPDATE_SOURCE_CHANGE;
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
} else
bgp_session_reset(peer);

/* Skip peer-group mechanics for regular peers. */
return 0;
}

..

for (ALL_LIST_ELEMENTS(peer->group->peer, node, nnode, member)) {
/* Skip peers with overridden configuration. */

..

/* Send notification or reset peer depending on state. */
if (BGP_IS_VALID_STATE_FOR_NOTIF(member->status)) {
member->last_reset = PEER_DOWN_UPDATE_SOURCE_CHANGE;
bgp_notify_send_hard_reset(member, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
} else
bgp_session_reset(member);

..

}

 

int peer_local_as_set(struct peer *peer, as_t as, int no_prepend,
int replace_as)
{

..

/* Check if handling a regular peer. */
if (!CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)) {
/* Send notification or reset peer depending on state. */
if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status)) {
peer->last_reset = PEER_DOWN_LOCAL_AS_CHANGE;
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
} else
bgp_session_reset(peer);

..

for (ALL_LIST_ELEMENTS(peer->group->peer, node, nnode, member)) {


/* Send notification or stop peer depending on state. */
if (BGP_IS_VALID_STATE_FOR_NOTIF(member->status)) {
member->last_reset = PEER_DOWN_LOCAL_AS_CHANGE;
bgp_notify_send_hard_reset(member, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
} else
BGP_EVENT_ADD(member, BGP_Stop);

..

}

 

/* Set password for authenticating with the peer. */
int peer_password_set(struct peer *peer, const char *password)
{

..

/* Check if handling a regular peer. */
if (!CHECK_FLAG(peer->sflags, PEER_STATUS_GROUP)) {
/* Send notification or reset peer depending on state. */
if (BGP_IS_VALID_STATE_FOR_NOTIF(peer->status))
bgp_notify_send_hard_reset(peer, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
else
bgp_session_reset(peer);

..

}

for (ALL_LIST_ELEMENTS(peer->group->peer, node, nnode, member)) {

..

/* Send notification or reset peer depending on state. */
if (BGP_IS_VALID_STATE_FOR_NOTIF(member->status))
bgp_notify_send_hard_reset(member, BGP_NOTIFY_CEASE,
BGP_NOTIFY_CEASE_CONFIG_CHANGE);
else
bgp_session_reset(member);

..

}

3.2.10.2.6. Connection Collision Resolution
According to RFC 8538 it is suggested  "Connection Collision Resolution": i.e. code 7, it would  follow Graceful Cease. I propose we should follow the Graceful Cease path in FRR. So this section is just a place holder and i am not listing the functions here. 

3.2.11. Interaction with Other Specifications
RFC 8203 [BGP Administrative Shutdown Communication] specifies the data portion of the Administrative Shutdown or Administrative Reset subcodes to convey a short message. I didnot find any mention of compliance with RFC 8203 in FRR bgp code. However when we do "clear bgp *" from cli, peer_clear() gets called, which send Admin Reset notification to its neighbor, with the data portion as NULL.

While implementing Hard Reset as per RFC 8538, it has been kept in mind that, if we ever plan to implement RFC 8203 in future for FRR, it would work conjunction with RFC 8538. So, the subcode of the outermost Cease MUST be Hard Reset, with the Administrative Shutdown or Administrative Reset subcodes encapsulated within.  The encapsulated message MUST subsequently be processed according to RFC8203, by the respective module when it is implemented.These changes are taken care by "section 3.2.8 Sending Hard Reset Notification".

3.2.12. Packet Debug for this feature
This section is for dumping the notification packets for debugging. This section is not yet complete.

Pseudocode :

static const struct message bgp_notify_cease_msg[] = {

..

{BGP_NOTIFY_CEASE_OUT_OF_RESOURCE, "/Out of Resource"},

{BGP_NOTIFY_CEASE_HARD_RESET, "/Hard Reset the BGP session"},

{0}};



const char *bgp_notify_subcode_str(char code, char subcode)
{

..

case BGP_NOTIFY_CAPABILITY_ERR:
return lookup_msg(bgp_notify_capability_msg, subcode,
"Unrecognized Error Subcode");

case BGP_NOTIFY_CEASE_HARD_RESET:

return lookup_msg(bgp_notify_capability_msg, subcode,
"Unrecognized Error Subcode");

}
return "";

}

 

/* dump notify packet */
void bgp_notify_print(struct peer *peer, struct bgp_notify *bgp_notify,
const char *direct)
{

..

if (bgp_notify->code == BGP_NOTIFY_CEASE
&& (bgp_notify->subcode == BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN
|| bgp_notify->subcode
== BGP_NOTIFY_CEASE_ADMIN_RESET)) {
msg_str = bgp_notify_admin_message(
msg_buf, sizeof(msg_buf), bgp_notify->raw_data,
bgp_notify->length);
}

..

}

3.2.13. Show Commands for this feature
The show command to be implemented for this feature. This section is not yet complete.

4. Caveats:
